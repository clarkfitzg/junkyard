Studying Hadley Wickham's Advanced R book.

```{r, echo=FALSE}
a = 1:10
typeof(a)
class(a)
attributes(a)
attributes(a) = list(style='awesome', foo='bar')
is.vector(a)
str(a)
attr(a, 'foo') = 1:5
attr(a, 'foo') 
```
So we can set arbitrary attributes on vectors.

What's the difference between `typeof` and `class`?
I think typeof is the underlying storage.

```{r, echo=FALSE}
b = c(1, 2, NA_character_)
b
```
Coerces to character. Fair enough

```{r, echo=FALSE}
     is.a.r <- function(x) c(is.atomic(x), is.recursive(x))

x = c(a=1, b=12)
class(x)
x
attributes(x)
str(x)
     is.a.r(c(a = 1, b = 3)) # TRUE FALSE
     is.a.r(list())          # FALSE TRUE - a list is a list
     is.a.r(list(2))         # FALSE TRUE
     is.a.r(lm)              # FALSE TRUE
     is.a.r(y ~ x)           # FALSE TRUE
     is.a.r(expression(x+1)) # FALSE TRUE (nowadays)

f1 = y ~ x
str(f1)
is.list(f1)
class(f1)
```
#curious
The formula is not a list but is still recursive. Why?
How is a formula stored internally?

We see that names are accessible from attributes.


```{r, echo=FALSE}

l = c(TRUE, FALSE)
typeof(l)
# Coercion
l2 = c(l, 2)
l2
l3 = c(l2, 1.3)
l3
l4 = c(l3, 'abc')
l4

a = NA
typeof(a)
```

The order of coercion: logical, integer, double, string

Hence NA is logical by default- it just gets coerced into whatever it
should actually be. That's convenient. p. 19

```{r, echo=FALSE}
x = list(list(1, 2), list(3, 4))
str(x)
y = list(list(1, 2), c(3, 4))
str(y)
y[[2]]
z = c(list(1, list(72)), list(3, 4))
str(z)
a = list(list(1, 2), 3)
a
unlist(a)
unlist(a, recursive=F)
```

So it looks like `c` flattened the list while `list` preserves the
structure.

Also, unlist is recursive by default.
