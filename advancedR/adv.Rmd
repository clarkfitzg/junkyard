Studying Hadley Wickham's Advanced R book.

```{r, echo=FALSE}
a = 1:10
typeof(a)
class(a)
attributes(a)
attributes(a) = list(style='awesome', foo='bar')
is.vector(a)
str(a)
attr(a, 'foo') = 1:5
attr(a, 'foo') 
```
So we can set arbitrary attributes on vectors.

What's the difference between `typeof` and `class`?
I think typeof is the underlying storage.

```{r, echo=FALSE}
b = c(1, 2, NA_character_)
b
```
Coerces to character. Fair enough

```{r, echo=FALSE}
     is.a.r <- function(x) c(is.atomic(x), is.recursive(x))

x = c(a=1, b=12)
class(x)
x
attributes(x)
str(x)
     is.a.r(c(a = 1, b = 3)) # TRUE FALSE
     is.a.r(list())          # FALSE TRUE - a list is a list
     is.a.r(list(2))         # FALSE TRUE
     is.a.r(lm)              # FALSE TRUE
     is.a.r(y ~ x)           # FALSE TRUE
     is.a.r(expression(x+1)) # FALSE TRUE (nowadays)

f1 = y ~ x
str(f1)
is.list(f1)
class(f1)
```
#curious
The formula is not a list but is still recursive. Why?
How is a formula stored internally?

We see that names are accessible from attributes.


```{r, echo=FALSE}

l = c(TRUE, FALSE)
typeof(l)
# Coercion
l2 = c(l, 2)
l2
l3 = c(l2, 1.3)
l3
l4 = c(l3, 'abc')
l4

a = NA
typeof(a)
```

The order of coercion: logical, integer, double, string

Hence NA is logical by default- it just gets coerced into whatever it
should actually be. That's convenient. p. 19

```{r, echo=FALSE}
x = list(list(1, 2), list(3, 4))
str(x)
y = list(list(1, 2), c(3, 4))
str(y)
y[[2]]
z = c(list(1, list(72)), list(3, 4))
str(z)
a = list(list(1, 2), 3)
a
unlist(a)
unlist(a, recursive=F)
```

So it looks like `c` flattened the list while `list` preserves the
structure.

Also, unlist is recursive by default.

```{r, echo=FALSE}
a = list(x = 1:10, y=list(a = 1, b = 2))
a
str(a)
b = structure(a, foo='bar')
attributes(b)
```
structure to add new attributes

Names, dim, and class are the most important attributes

```{r, echo=FALSE}
x = c(a=1, b=2)
names(x) = 'hello'
x
str(x)
names(x) = NULL
unname(x)
f = function(x){
    setNames(x, c('a', 'b'))
}
f(1:4)
```

So names doesn't recycle. Just sets the first k if there are too few
specified.

```{r, echo=FALSE}
x = factor(c('a', 'b', 'a'))
y = factor(c('a', 'b', 'a'))
x
#x[2] = 'd'
#y = c(factor('a'), factor('b'))
z = c(x, y)
z
levels(x) = c('b', 'a')
x
rev(1:5)
# A nice way to get a mapping of letters to integers
rev(factor(letters))
factor(letters, levels = rev(letters))
# This changes the encoding so that z is 1 and a is 26.

l = factor(letters)
l
levels(l) = rev(letters)
# Updating levels later changes:
#       oldlevel --> newlevel
```

Don't try to combine factors with c- doesn't work.
Modifying levels changes how they are encoded.

```{r, echo=FALSE}
x = structure(1:4, foo='bar')
x
structure(1:4, foo='bar')
```
The above seems to print just fine. Ex 2.2.2.1


```{r, echo=FALSE}
a = 1:12
a
dim(a)
dim(a) = c(2, 6)
class(a)
dim(a) = c(2, 2, 3)
class(a)
dim(a)
dimnames(a) = list(c('r1', 'r2'), c('c1', 'c2'), c('f1', 'f2', 'f3'))
a
```

Numpy arrays have much in common with R vectors.

