Studying Hadley Wickham's Advanced R book.

```{r, echo=FALSE}
a = 1:10
typeof(a)
class(a)
attributes(a)
attributes(a) = list(style='awesome', foo='bar')
is.vector(a)
str(a)
attr(a, 'foo') = 1:5
attr(a, 'foo') 
```
So we can set arbitrary attributes on vectors.

What's the difference between `typeof` and `class`?
I think typeof is the underlying storage.

```{r, echo=FALSE}
b = c(1, 2, NA_character_)
b
```
Coerces to character. Fair enough

```{r, echo=FALSE}
     is.a.r <- function(x) c(is.atomic(x), is.recursive(x))

x = c(a=1, b=12)
class(x)
x
attributes(x)
str(x)
     is.a.r(c(a = 1, b = 3)) # TRUE FALSE
     is.a.r(list())          # FALSE TRUE - a list is a list
     is.a.r(list(2))         # FALSE TRUE
     is.a.r(lm)              # FALSE TRUE
     is.a.r(y ~ x)           # FALSE TRUE
     is.a.r(expression(x+1)) # FALSE TRUE (nowadays)

f1 = y ~ x
str(f1)
is.list(f1)
class(f1)
```
#curious
The formula is not a list but is still recursive. Why?
How is a formula stored internally?

We see that names are accessible from attributes.


```{r, echo=FALSE}

l = c(TRUE, FALSE)
typeof(l)
# Coercion
l2 = c(l, 2)
l2
l3 = c(l2, 1.3)
l3
l4 = c(l3, 'abc')
l4

a = NA
typeof(a)
```

The order of coercion: logical, integer, double, string

Hence NA is logical by default- it just gets coerced into whatever it
should actually be. That's convenient. p. 19

```{r, echo=FALSE}
x = list(list(1, 2), list(3, 4))
str(x)
y = list(list(1, 2), c(3, 4))
str(y)
y[[2]]
z = c(list(1, list(72)), list(3, 4))
str(z)
a = list(list(1, 2), 3)
a
unlist(a)
unlist(a, recursive=F)
```

So it looks like `c` flattened the list while `list` preserves the
structure.

Also, unlist is recursive by default.

```{r, echo=FALSE}
a = list(x = 1:10, y=list(a = 1, b = 2))
a
str(a)
b = structure(a, foo='bar')
attributes(b)
```
structure to add new attributes

Names, dim, and class are the most important attributes

```{r, echo=FALSE}
x = c(a=1, b=2)
names(x) = 'hello'
x
str(x)
names(x) = NULL
unname(x)
f = function(x){
    setNames(x, c('a', 'b'))
}
f(1:4)
```

So names doesn't recycle. Just sets the first k if there are too few
specified.

```{r, echo=FALSE}
x = factor(c('a', 'b', 'a'))
y = factor(c('a', 'b', 'a'))
x
#x[2] = 'd'
#y = c(factor('a'), factor('b'))
z = c(x, y)
z
levels(x) = c('b', 'a')
x
rev(1:5)
# A nice way to get a mapping of letters to integers
rev(factor(letters))
factor(letters, levels = rev(letters))
# This changes the encoding so that z is 1 and a is 26.

l = factor(letters)
l
levels(l) = rev(letters)
# Updating levels later changes:
#       oldlevel --> newlevel
```

Don't try to combine factors with c- doesn't work.
Modifying levels changes how they are encoded.

```{r, echo=FALSE}
x = structure(1:4, foo='bar')
x
structure(1:4, foo='bar')
```
The above seems to print just fine. Ex 2.2.2.1


```{r, echo=FALSE}
a = 1:12
a
dim(a)
dim(a) = c(2, 6)
class(a)
typeof(a) # Underlying storage
dim(a) = c(2, 2, 3)
class(a)
dim(a)
dimnames(a) = list(c('r1', 'r2'), c('c1', 'c2'), c('f1', 'f2', 'f3'))
a
```

Numpy arrays have much in common with R vectors. But can Numpy arrays store
various objects? That is, be recursive? Yes.


```{r, echo=FALSE}
x = 1:12
x = as.array(x, dim=c(2, 3, 2)) # Why isn't this working?
array(1:12, dim=c(2, 3, 2))
x
y = array(1:12, dim=c(2, 6))
y
class(y) # it's a matrix
as.matrix(1:12, dim=c(2, 6))
```

Was wondering why this as.matrix didn't work as expected. Looking at the
code for `as.matrix.default` I see why. Better to use `matrix` and then
as.matrix for dataframes.

```{r, echo=FALSE}
a = data.frame(x=1:2, y=3:4)
a
as.matrix(a)
matrix(a)
b = as.vector(a)
class(b) # Still a dataframe. Strange
```

Did not realize that one could set the dim for a list. Not commonly done.

```{r, echo=FALSE}
x = list(a=1, b='cats', c=1:4, d=TRUE)
x
dim(x) = c(2, 2)
x[[1, 2]]
names(x)
# Seems that it lost the names
is.matrix(x) # TRUE - kind of surprising
dim(1:3)
```

So is.matrix just checks if it has the dim attribute set? No since a data
frame is not a matrix. So that's not particularly consistent.

```{r, echo=FALSE}
a = data.frame(x=1:2, y=c('one', 'two'), stringsAsFactors=FALSE)
a
sapply(a, class)
is.matrix(a)
dim(a)
str(a)
class(a)
typeof(a)

library(plyr)
b = data.frame(x = 3:4)
a
b
rbind(a['x'], b)

# Lets try error handling
binder = function(x, y){
    # rbind x and y, with error handling
    tryCatch(rbind(x, y), error = function(e) 'Kaboom!', 
             finally = print('its all over'))
}
d = binder(a, b)
d
e = binder(a['x'], b)
e

f = plyr::rbind.fill(a, b)
is.na(f[3, 4])  # False
is.null(f[3, 4])  # True
```

Good that rbind throws an error if the names do not match.
The body of is.data.frame is quite simple.


```{r, echo=FALSE}
crazy = data.frame(x=1:3)
crazy$y = matrix(1:6, nrow=3)
crazy
dim(crazy)
```
Just because you can use arrays and such as columns for dataframes doesn't
mean that you should.


```{r, echo=FALSE}
a = data.frame(x=1:2, y=c('a','b'))
as.matrix(a)
b = data.frame(x=NULL, y=NULL)
dim(b)
b
b[1,1]
rbind(a, b)
cbind(a, b)
```

as.matrix on dataframe coerces to most generic type.
Yes, you can make a data frame with no rows / columns
rbind works but cbind does not.
